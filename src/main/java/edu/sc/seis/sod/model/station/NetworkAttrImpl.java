// **********************************************************************
//
// Generated by the ORBacus IDL to Java Translator
//
// Copyright (c) 2000
// Object Oriented Concepts, Inc.
// Billerica, MA, USA
//
// All Rights Reserved
//
// **********************************************************************
// Version: 4.0.3
package edu.sc.seis.sod.model.station;

import java.lang.ref.WeakReference;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import edu.sc.seis.sod.model.common.MicroSecondDate;
import edu.sc.seis.sod.model.common.Time;
import edu.sc.seis.sod.model.common.TimeRange;

//
// IDL:iris.edu/Fissures/IfNetwork/NetworkAttr:1.0
//
/***/
public class NetworkAttrImpl  {
    /** Identifies a network uniquely. */

    protected NetworkId id;

    //
    // IDL:iris.edu/Fissures/IfNetwork/NetworkAttr/name:1.0
    //
    /** A name for this network. The form of this is not specified, 
     *  but it should be suitable for display to a person. It is not 
     *  nescessarily unique. */

    private String name;

    //
    // IDL:iris.edu/Fissures/IfNetwork/NetworkAttr/description:1.0
    //
    /**A description of the network. The form of this is not specified, but
     *should be suitable for display to a person.
     **/

    private String description;

    //
    // IDL:iris.edu/Fissures/IfNetwork/NetworkAttr/owner:1.0
    //
    /** The owner or owning agency of the network. */

    private String owner;

    //
    // IDL:iris.edu/Fissures/IfNetwork/NetworkAttr/effective_time:1.0
    //
    /** The effective time range of the network. The begin should be at or 
     *  before any station within the network records data. If the network
     * is still operating at the present time, then the end should be set
     * to TIME_UNKNOWN as defined in IfConstants.idl.
     **/

    private TimeRange effective_time;


    
    protected NetworkAttrImpl() {}

    public static NetworkAttrImpl createEmpty() {
        return new NetworkAttrImpl();
    }

    public NetworkAttrImpl(NetworkId id,
                           String name,
                           String description,
                           String owner,
                           TimeRange effective_time) {
        this.id = id;
        this.setName(name);
        this.setDescription(description);
        this.setOwner(owner);
        this.setEffectiveTime(effective_time);
    }

    /**
     * creates a net NetworkAttr with effective begin extracted from the
     * NetworkId and effective end unknown, ie still operational.
     */
    public NetworkAttrImpl(NetworkId id,
                           String name,
                           String description,
                           String owner) {
        this(id,
             name,
             description,
             owner,
             new TimeRange(id.begin_time,
                           (MicroSecondDate)null));
    }

    //
    // IDL:iris.edu/Fissures/IfNetwork/NetworkAttr/get_id:1.0
    //
    public NetworkId get_id() {
        return id;
    }

    //
    // IDL:iris.edu/Fissures/IfNetwork/NetworkAttr/get_code:1.0
    //
    public String get_code() {
        return id.network_code;
    }
    
    /** Updates the network begintime in the networkId and effective time. Usually this is
     * because of a change in a remote database causing a local update to be needed.
     */
    public void updateBeginTime(Time t) {
        getId().begin_time = t;
        setBeginTime(t);
    }
    
    protected int dbid;
    protected String sourceServerName;
    protected String sourceServerDNS;
    
    
    public String getSourceServerName() {
        return sourceServerName;
    }

    public void setSourceServerName(String sourceServerName) {
        this.sourceServerName = sourceServerName;
    }
    
    public String getSourceServerDNS() {
        return sourceServerDNS;
    }
    
    public void setSourceServerDNS(String sourceServerDNS) {
        this.sourceServerDNS = sourceServerDNS;
    }

    protected void setDbid(int dbid) {
        this.dbid = dbid;
    }
    public int getDbid() {
        return dbid;
    }
    public void associateInDB(NetworkAttrImpl attr) {
        setDbid(attr.getDbid());
    }
    
    public boolean equals(Object o) {
    	if (o instanceof NetworkAttrImpl) {
    		NetworkAttrImpl n = (NetworkAttrImpl)o;
    		return NetworkIdUtil.areEqual(get_id(), n.get_id());
    	}
    	return false;
    }
    
    public int hashCode() {
    	return NetworkIdUtil.hashCode(get_id());
    }
    
    public String toString() {
        return NetworkIdUtil.toString(this);
    }
    
    public String getName() {
        return name;
    }

    public TimeRange getEffectiveTime() {
        return effective_time;
    }

    public String getOwner() {
        return owner;
    }

    public String getDescription() {
        return description;
    }

    // hibernate
    public NetworkId getId() {
        return get_id();
    }

    public void setId(NetworkId netId) {
        this.id = netId;
        setBeginTime(netId.begin_time);
    }

    public void setName(String name) {
        this.name = name;
    }


    public void setOwner(String owner) {
        this.owner = owner;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Time getBeginTime() {
        return get_id().begin_time;
    }
    
    public void setBeginTime(Time beginTime) {
        if (getEffectiveTime() == null) {
            setEffectiveTime(new TimeRange(beginTime, (MicroSecondDate)null));
        } else {
            setEffectiveTime(new TimeRange(beginTime, getEffectiveTime().getEndTime()));
        }
        if (id != null) {
            id.begin_time = beginTime;
        }
    }
    
    public MicroSecondDate getEndTime() {
        return getEffectiveTime().getEndTime();
    }
    
    public void setEndTime(Time endTime) {
        if (getEffectiveTime() == null) {
            setEffectiveTime(new TimeRange(null, endTime));
        } else {
            setEffectiveTime(new TimeRange(getEffectiveTime().getBeginTime(), endTime));
        }
    }
    
    public static String intern(String s) {
        if (s != null) {
            return s.intern();
        } else {
            return "".intern();
        }
    }
    
    public static NetworkAttrImpl intern(NetworkAttrImpl attr) {
        synchronized(knownTimes) {
            String key = attr.getId().network_code+attr.getId().begin_time.getISOString();
            NetworkAttrImpl interned = null;
            if (knownNetworks.containsKey(key)) {
                // don't return here, still need to check for null due to weak reference
                interned = knownNetworks.get(key).get();
            }
            if(interned == null) {
                knownNetworks.put(key, new WeakReference<NetworkAttrImpl>(attr));
                attr.setDescription(intern(attr.getDescription()));
                attr.setName(intern(attr.getName()));
                attr.setOwner(intern(attr.getOwner()));
                intern(attr.get_id());
                return attr;
            }
            return interned;
        }
    }

    public static NetworkId intern(NetworkId id) {
        id.begin_time = intern(id.begin_time);
        id.network_code = id.network_code.intern();
        return id;
    }
    
    public static TimeRange intern(TimeRange effective_time) {
        return new TimeRange(intern(effective_time.getBeginTime()), 
                             intern(effective_time.getEndTime()));
    }

    public static Time intern(MicroSecondDate unknownTime) {
        return intern(new Time(unknownTime));
    }
    
    public static Time intern(Time unknownTime) {
        synchronized(knownTimes) {
            long key = unknownTime.getMicroSecondTime();
            Time interned = null;
            if (knownTimes.containsKey(key)) {
                interned = knownTimes.get(key).get();
            }
            if(interned == null) {
                knownTimes.put(key, new WeakReference<Time>(unknownTime));
                return unknownTime;
            }
            return interned;
        }
    }

    protected void setEffectiveTime(TimeRange effective_time) {
        this.effective_time = effective_time;
    }

    private static Map<Long, WeakReference<Time>> knownTimes = Collections.synchronizedMap(new HashMap<Long, WeakReference<Time>>());
    
    private static Map<String, WeakReference<NetworkAttrImpl>> knownNetworks = Collections.synchronizedMap(new HashMap<String, WeakReference<NetworkAttrImpl>>());

}
